---
title: CS106b
date: 2025-10-25
tags: [CS106b, c++]
head:
  - - meta
    - name: code
      content: tinf
  - - meta
    - name: think_process
      content: tinf
---

记录CS106b学习过程

---

## assignment5 combine

好无语啊之前的思路都没用记录下来感觉好可惜...(o(╥﹏╥)o)
讨厌香水。讨厌香水。讨厌香水。
不是我觉得我如果要把自己学习过程写下来的话每篇都能写k字往上啊（（（因为实在是太好玩了，乐啊。。。。

测试了自己写的combine，然后...
!!!垂死病中惊坐起！！想起来了，
```cpp
Vector<DataPoint> combine(const Vector<Vector<DataPoint>>& sequences) {
    /* TODO: Delete the next few lines and implement this. */

    if (sequences.size() == 0) return {};
    if (sequences.size() == 1) return sequences[0];
    int mid = sequences.size() / 2;
    Vector<Vector<DataPoint>> left = sequences.subList(0, mid);
    Vector<Vector<DataPoint>> right = sequences.subList(mid);


    return merge(combine(left), combine(right));
}
Vector<DataPoint> merge(const Vector<DataPoint>& a, const Vector<DataPoint>& b){
    Vector<DataPoint> result;
    int i = 0, j = 0;

    // 比较并合并
    for (; i < a.size() && j < b.size(); ) {
        if (a[i].weight <= b[j].weight) {
            result.add(a[i]);
            i++;
        } else {
            result.add(b[j]);
            j++;
        }
    }

    // 处理a剩下的元素
    while (i < a.size()) {
        result.add(a[i]);
        i++;
    }

    // 处理b剩下的元素
    while (j < b.size()) {
        result.add(b[j]);
        j++;
    }

    return result;
}
```
当时看到题目就很迷惑，什么测试案例给的什么东西啊...然后发现是用一种教幼儿园小朋友的方式把几个数列集合串起来，，，给数字起名字了，然后用datapoint包个名字，其实比较像一个帮派(vector)里每个人和每个人的资产排个等级，另一个帮派排个等级这样，然后合并
果断想如何插入啊，然后就是查文档问题...实际并不是
貌似是cs50讲过的什么排序来着，md名字我也不记得了，反正就是喊人上去一点点摆那个场景记得倒挺清楚的，
于是立刻就去写了，发现不会写，
重新看题目，知道该如何排序了，但具体落实到代码实现依然毫无思路，就，两个两个vector分组，然后把它们合并到一块去》但是很奇怪，我应该判断从左到右，数字是否根据两组而定？大于左边小于右边就插入这个数。。。吗？然后一层层递归
现在考虑最简单的情况：只有两个序列，每个序列都只有一个元素。就是直接连成{1，2}啊，它大小已经排好了？...还要比较序列之间的大小...但是如果是插空的那种还需要递归是吗？...裂开再递归，判断两者第一个数字，输出小的小就可以了，但是分组这个活也需要我写代码吗？先把4个序列分成两组：
第一组: [{1}, {3}]   第二组: [{2}, {4}]
..不是，我在想分组这个过程难道不还是要把大小比一遍再放入lefthalf和righthalf吗？...分组只看位置，不看内容：

```md
输入: [{1}, {3}, {2}, {4}]
        ↑    ↑    ↑    ↑
        0    1    2    3     ← 只看下标位置

分组：
- 左半：下标0,1 → [{1}, {3}]  
- 右半：下标2,3 → [{2}, {4}]
```

完全不关心 {1} 和 {3} 谁大谁小，也不关心 {2} 和 {4} 谁大谁小。
排序发生在递归合并的时候：

```md
左半 [{1}, {3}] 
     ↓ (递归调用combine)
合并 {1} 和 {3} → 得到 {1,3}

右半 [{2}, {4}]
     ↓ (递归调用combine)  
合并 {2} 和 {4} → 得到 {2,4}
```
那如果是4123咋办？...不对，它序列里会自动排好序。。
...大概想通过程了，那递归就基础情况就是如果只剩下两个序列return 小的那一列，然后再分成个数相同的两列。
基础情况：
```cpp
if (lists.size() == 0) return {};
if (lists.size() == 1) return lists[0];
```
我觉得我这种 分组计算写的好麻烦...?
```cpp
    for(Vector<DataPoint> p : sequences){
        left.add(p);
        if(count == mid)
            break            
    }
```
实际可以这样：
```cpp
Vector<Vector<DataPoint>> left = sequences.subList(0, mid);
Vector<Vector<DataPoint>> right = sequences.subList(mid);
```
分成两半但是仍然不知道下一步该如何行进？明明想的是只有输出小的那一个就行，，，if比较吗？而且这是个序列集合...?
```cpp
Vector<DataPoint> combine(const Vector<Vector<DataPoint>>& sequences) {
    /* TODO: Delete the next few lines and implement this. */

    if (sequences.size() == 0) return {};
    if (sequences.size() == 1) return sequences[0];
    int mid = sequences.size() / 2;
    Vector<Vector<DataPoint>> left = sequences.subList(0, mid);
    Vector<Vector<DataPoint>> right = sequences.subList(mid);


    return combine(left) + combine(right);
}
```
combine(left) 返回一个有序序列，combine(right) 返回一个有序序列，但 + 只是把它们连接起来，不是按顺序合并
比较 A[左手指的位置] 和 B[右手指的位置]：
- 1 < 2 → 把1加入结果，左手指向右移动一位
- 现在左手指着3，右手指着2
- 3 > 2 → 把2加入结果，右手指向右移动一位  
- 现在左手指着3，右手指着4
- 3 < 4 → 把3加入结果，左手指向右移动一位
... 以此类推
不知道什么鬼啊，只能想出很逆天的for（int i）
就是用 for (int i) 这种循环，但需要两个索引：
for里面是不能这么写吗？for((int i = 0; i < a.size() ;i++ ) && (int j = 0; j < b.size(); j++))
确实不能。
```cpp
int i = 0, j = 0;
while (i < a.size() && j < b.size()) {
    // 比较逻辑
    i++; 或 j++;  // 手动控制移动
}
```

```cpp
Vector<DataPoint> combine(const Vector<Vector<DataPoint>>& sequences) {
    /* TODO: Delete the next few lines and implement this. */

    if (sequences.size() == 0) return {};
    if (sequences.size() == 1) return sequences[0];
    int mid = sequences.size() / 2;
    Vector<Vector<DataPoint>> left = sequences.subList(0, mid);
    Vector<Vector<DataPoint>> right = sequences.subList(mid);


    return merge(combine(left), combine(right));
}
Vector<DataPoint> merge(const Vector<DataPoint>& a,const Vector<DataPoint>& b){
    Vector<DataPoint> result;
    int i = 0, j = 0;
    for (; i < a.size() && j < b.size(); ) {
        if (a[i].weight <= b[j].weight) {
            result.add(a[i]);
            i++;
        } else {
            result.add(b[j]);
            j++;
        }
    }
    return result;

}
```
没有处理剩余元素。

a = [1, 3, 5]
b = [2, 4]

merge过程：
i=0,j=0: 1<2 → 输出1, i=1
i=1,j=0: 3>2 → 输出2, j=1  
i=1,j=1: 3<4 → 输出3, i=2
i=2,j=1: 循环结束（i=2 == a.size()）

但b还有剩余：[4] 没有输出
...在循环外面if一个如果a/b不为空就把最后的加上去就可以了。。
最后就可以（嗯。

然后时间复杂度大概是这样...
·把所有元素扔进大数组 + 排序 → O(n log n)
·维护一个大数组，逐个插入新序列 → O(nk)

题目给的思路：
递归深度：log₂k

每次递归都把k个序列分成两半

k=8 → 4 → 2 → 1 (3层)

k=1024 → 10层

每层工作量：O(n)

每层都要归并所有n个元素

但归并是O(n)操作

**总时间：O(n) × O(log k) = O(n log k)**

## binary heap/heap 
。。。写完以上其实又写完了binary heap。。。然后又能写千字小作文了。。。。
想出binary heap二叉树和数组转换机制的是家里请高人了吗？。。
哎等等，我不一定要用assignment计数，嗯对。因为逐渐写cs106b的情况就是不知道它要问什么但是可以一口气都写完（离谱。。回过头才发现自己都写过了。。。。